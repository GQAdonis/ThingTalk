// -* mode: js -*-

SearchYoutube() {
        $now => @youtube.search_videos(foo, link), link = $makeURL("http://www.youtube.com") =>  @$notify();
}

====

// Runs in a shared chat room. Anything that is sent to the chat that doesn't
// end with two spaces or doesn't start with 'detect' or 'translate' is
// translated. The 'detect' command can also be used to detect text language.
Translate[F]() {
	out TargetLang : String;
	!TargetLang(_) => TargetLang("ru");

  var Leader[F] : Boolean;
!Leader[self](_) => Leader[self](true);
	Leader[self](true), Leader[m](_), m in F, m.name < self.name => Leader[self](false);

	@omlet.newmessage(F,type,t), $regex(t, "^translate help$", "i", tgt) => @omlet.send(F, "text", "usage: translate set-target code\nusage: translate get-target\nusage: detect ...\nusage: [text to translate]  ");

	// set the target language
	@omlet.newmessage(F,type,t), $regex(t, "^translate set-target (.+)$", "i", tgt) => TargetLang(tgt);

	// what is the target language?
	@omlet.newmessage(F,type,t), $regex(t, "^translate get-target$", "i"), TargetLang(tgt) => @omlet.send(F, "text", tgt + "  ");

	// translate message
	@omlet.newmessage(F,type,t), !$regex(t, "^translate", "i"), !$regex(t, "^detect", "i"), !$regex(t, "  $", ""), $regex(t, "^(.+)$", "i", text), Leader[self](true), TargetLang(tgt) => @ytranslate.translate("", tgt, text, result) => @omlet.send(F, "text", "@" + tgt + ": " + result + "  ");

	// get source language
	@omlet.newmessage(F,type,t), $regex(t, "^detect\\:? (.+)$", "i", text), Leader[self](true) => @ytranslate.detect_language(text, language), Leader[self](true) => @omlet.send(F, "text", "detected: " + language + "  ");
}

====

RandomMeme() {
@$timer(24h), meme := $choice([["the most interesting man in the world", "I don't always make memes", "but when I do it's on Sabrina"], ["futurama fry", "Not sure if automated", "Or just dumber than usual"],["ancient aliens", "", "Research"], ["brace yourselves", "Brace yourselves", "Automated memes are coming"]]) => @imgflip.generate($at(meme, 0), $at(meme, 1), $at(meme, 2), _, url) => @facebook.post_picture(url);
}
====

PhoneNumberTest() {
  $now => @phone.send_sms("+15555555555", "");
  $now => @phone.send_sms($makePhoneNumber("+15555555555"), "");
  @phone.receive_sms($makePhoneNumber("+15555555555"), _) => @$notify();
}

====

InvalidPhoneNumberTest() {
  $now => @phone.send_sms($makeEmailAddress("+15555555555"), "");
}

====

EnumTest() {
  @omlet.incomingmessage(_, "new", text) => @$notify();
}

====

InvalidTriggerParam() {
  @sabrina.listen($choice(["bla", "blo"])) => @$notify();
}

====

LocationAsTriggerParam() {
  @weatherapi.weather($makeLocation(1, 3), temperature) => @$notify();
}

====

SabrinaGeneratedMonitorTwitter() {
    @(type="twitter", id="twitter-foo").source(text, hashtags, urls, "HillaryClinton", inreplyto, __reserved) => @$notify();
}

====

CommandTest() {
  @sabrina.say("test");
  $now => @sabrina.say("test");
  $now => @ninegag.get_latest(title, link, pic) => @sabrina.picture(pic);
}

====

SabrinaChangeNestTemperature(Thermostat : String) {
@sabrina.listen(text), $regex(text, "set\\s+nest\\s+temp(?:erature)?\\s+(?:to\\s+)?([0-9\\.]+)\\s*C?", "i", temp) =>
@(type="thermostat", name=Thermostat).set_target_temperature($valueOf(temp)*1C);
}
====

SabrinaLikesItHot(Thermostat : String, Threshold : Measure(C)) {
@(type="thermostat", name=Thermostat).temperature(_, t), t > Threshold => @$notify("bla");
@(type="thermostat", name=Thermostat).temperature(_, t), t > Threshold => @$notify("bla " + $toString(t));
@(type="thermostat", name=Thermostat).temperature(_, t), t > Threshold => @$notify("bla " + $toString($random()));
}

====

GetRetweets() {
    @sabrina.listen(what), $regex(what, "get retweets from ([a-z0-9]+)", "i", who) =>
    @twitter.retweets_of_me(text, hashtags, urls, who) => @sabrina.say("Retweet from " + who + ": " + text);
}

====

IndianAstrology() {
   var sunDuration: Measure(ms);
   var setToday: String;
   var riseToday: String;
   var day: String;
   var hour: String;
   var min: String;
   var sec: String;
   @weatherapi.sunrise(37, 122, rise, set) => setToday($toString(set)), riseToday($toString(rise)), sunDuration(set - rise);
   setToday(x), $regex(setToday, "^(Mon|Tue|Wed|Thu|Fri|Sat|Sun).*([0-9][0-9]):([0-9][0-9]):([0-9][0-9])", "i", day, hour, min, sec) => @$notify("Sunset today which is a " + day + " is at " + hour + " hr " + min + " m " + sec + " s");
   //sunDuration(_) => @$notify("Unit of sun today is: " + $toString($valueOf($toString(sunDuration))/8) + " ms");
}

====

TestTupleUnpack() {
    var V : Array((String, String));
    var V2 : (String, String);

    V(a), $contains(a, v) => V2(v);
}

====

TM[F] () {
// Look on my works, ye Mighty, and despair!
// Runs a distributed Turing Machine interpreter, using round-robin to run it on
// each of the users within a feed's ThingEngines. Mostly for fun, but
// demonstrates that ThingTalk is a Turing-complete language.
// I would have written a shorter program but I did not have time. Also, the
// language is sorely lacking in support for nested conditions, if-else type
// actions and multiple actions, which makes conciseness somewhat difficult.
// This better count as distributed social computation.

// Note: depending on how the data is propagated, there will be consistency
// issues. Also, due to the way ThingTalk execution works, if a variable is
// assigned a value but that is the same as its old value, any corresponding
// actions are _not_ rerun. This means that if you ask to run the same machine
// multiple times, it may not actually get executed. This is not a bug in this
// code. Of course, there are ways to get around it with some contortions but
// the code is convoluted enough as it is.

// -----------------------------------------------------------------------------
// The particular machine model we use here is a variant of a register machine.
// The allowed instructions are: i#r (i followed by a number, which we will
// denote r), d#r, t#q.
//   i#r: increment register r by 1, proceed to next instruction
//   d#r: if register r's value is 0, just proceed to the next instruction,
//        otherwise decrement r by 1 and jump one instruction
//   t#q: jump q instructions. q may be negative. If there is no such
//        instruction, halt.

// To actually run the Turing machine, in a feed say "run" followed by a space
// and the sequence of instructions, terminated by a colon and then a number
// representing the value of the first register (register 0). All other
// registers start with the value 0.
// So e.g. "run d0t3i1t-3:5" transfers the value of 5 from register 0 to 1.

// Step 0: leader election, to ensure only a single user within the feed parses
// any new commands.
out Leader[F] : Boolean;
!Leader[self](_) => Leader[self](true);
Leader[self](true), Leader[m](_), m in F, m.name < self.name => Leader[self](false);

@omlet.newmessage(feed, _, "Reset"), feed = F => Node($emptyMap()), Run(false), Done(true);

// Step 1: parse commands. Ideally this should be done by the person that sent
// the message, but the Omlet interface doesn't seem to allow us to figure that
// out so for now it is done by the leader.
out Reset : (String, Number);  // Unparsed command, start value
out Command : String;
// Instruction index, single character instruction, number in instruction, rest of command
out NewCommand : (Number, String, Number, String);

out Run : Boolean;
// Array indexing isn't supported, so we use maps instead.
// Map instruction index to single character instruction
out InstructionChars : Map(Number, String);
// Map instruction index to number in instruction
out InstructionNums : Map(Number, Number);
// Register number to value
out Registers : Map(Number, Number);

!InstructionNums(_) => InstructionNums($emptyMap());
!InstructionChars(_) => InstructionChars($emptyMap());

@omlet.newmessage(F, _, msg), Leader[self](true), $regex(msg, "^run (.*)\\:(\\d+)$", "i", cmd, startval) => Reset(cmd, $valueOf(startval));

Leader[self](true), Reset(cmd, startval) => Node($insert($emptyMap(), self, 0)),
                                              Run(false),
                                              InstructionChars($emptyMap()),
                                              InstructionNums($emptyMap()),
                                              Registers($insert($emptyMap(), 0, startval));

// Ensure all other reset actions have completed before starting this.
Leader[self](true), Reset(cmd, startval), Node(_), $contains(Node, self), Run(false), InstructionChars(_), $count(InstructionChars) = 0, InstructionNums(_), $count(InstructionNums) = 0, Registers(_), $lookup(Registers, 0) = startval => Command(cmd);

Leader[self](true), Command(cmd), $regex(cmd, "^([id])(\\d+)(\\D.*)$", "i", instr, regnum, rest) => NewCommand($count(InstructionChars), instr, $valueOf(regnum), rest);
Leader[self](true), Command(cmd), $regex(cmd, "^([id])(\\d+)$", "i", instr, regnum) => NewCommand($count(InstructionChars), instr, $valueOf(regnum), "");
Leader[self](true), Command(cmd), $regex(cmd, "^t(-?\\d+)(\\D.*)$", "i", inum, rest) => NewCommand($count(InstructionChars), "t", $valueOf(inum), rest);
Leader[self](true), Command(cmd), $regex(cmd, "^t(-?\\d+)$", "i", inum) => NewCommand($count(InstructionChars), "t", $valueOf(inum), "");

Leader[self](true), NewCommand(instr_i, instr, inum, rest) => InstructionChars($insert(InstructionChars, instr_i, instr)),
                                                                InstructionNums($insert(InstructionNums, instr_i, inum));
Leader[self](true), NewCommand(instr_i, instr, inum, rest), InstructionChars(_), $contains(InstructionChars, instr_i), InstructionNums(_), $contains(InstructionNums, instr_i) => Command(rest);
Leader[self](true), Command("") => State(0, 0), Done(false), RunInstr[self](-1, "_", -1), DecIntermediate[self](-1, false, 0, 0), IncIntermediate[self](-1, 0, 0);
Leader[self](true), Command(""), State(0, 0), Done(false), RunInstr[self](instr_r, _, _), instr_r = -1, DecIntermediate[self](instr_j, _, _, _), instr_j = -1, IncIntermediate[self](instr_j2, _, _), instr_j2 = -1 => Run(true);
Leader[self](true), Run(true) => @omlet.send(F, "text", "Parsing complete! Now running.");

// Step 3: run!
// We use round-robin scheduling among users. Of course, this is horrifically
// inefficient but that's besides the point. One could imagine batching multiple
// instructions to run on each node, but for simplicity we don't do that.
// Map user to their index
out Node : Map(User, Number);
// Current user index, instruction index
out State : (Number, Number);
// Instruction index, single character instruction, number in instruction
out RunInstr[F] : (Number, String, Number);
out Done : Boolean;
// Instruction index, register number, new register value
out IncIntermediate[F] : (Number, Number, Number);
// Instruction index, whether register's value was 0, register number, new register value
out DecIntermediate[F] : (Number, Boolean, Number, Number);

!Node(_) => Node($emptyMap());
Node(_), !$contains(Node, self) => Node($insert(Node, self, $count(Node)));

Run(true), Done(false), State(user_i, instr_i), $lookup(Node, self) = user_i => RunInstr[self](instr_i, $lookup(InstructionChars, instr_i), $lookup(InstructionNums, instr_i));
// i
Run(true), Done(false), State(user_i, instr_i), $lookup(Node, self) = user_i, RunInstr[self](instr_j, "i", inum), instr_j = instr_i, $contains(Registers, inum) => IncIntermediate[self](instr_i, inum, $lookup(Registers, inum) + 1);
Run(true), Done(false), State(user_i, instr_i), $lookup(Node, self) = user_i, RunInstr[self](instr_j, "i", inum), instr_j = instr_i, !$contains(Registers, inum) => IncIntermediate[self](instr_i, inum, 1);
Run(true), Done(false), State(user_i, instr_i), $lookup(Node, self) = user_i, IncIntermediate[self](instr_j, regnum, newval), instr_j = instr_i => Registers($insert(Registers, regnum, newval));
// Check for halt
Run(true), Done(false), State(user_i, instr_i), $lookup(Node, self) = user_i, IncIntermediate[self](instr_j, regnum, newval), instr_j = instr_i, Registers(_), $lookup(Registers, regnum) = newval, !$contains(InstructionChars, instr_i + 1) => Done(true);
// Check for user wraparound
Run(true), Done(false), State(user_i, instr_i), $lookup(Node, self) = user_i, IncIntermediate[self](instr_j, regnum, newval), instr_j = instr_i, Registers(_), $lookup(Registers, regnum) = newval, $contains(InstructionChars, instr_i + 1), user_i + 1 = $count(Node) => State(0, instr_i + 1);
Run(true), Done(false), State(user_i, instr_i), $lookup(Node, self) = user_i, IncIntermediate[self](instr_j, regnum, newval), instr_j = instr_i, Registers(_), $lookup(Registers, regnum) = newval, $contains(InstructionChars, instr_i + 1), user_i + 1 != $count(Node) => State(user_i + 1, instr_i + 1);
// d
Run(true), Done(false), State(user_i, instr_i), $lookup(Node, self) = user_i, RunInstr[self](instr_j, "d", inum), instr_j = instr_i, $contains(Registers, inum) && $lookup(Registers, inum) > 0 => DecIntermediate[self](instr_i, false, inum, $lookup(Registers, inum) - 1);
Run(true), Done(false), State(user_i, instr_i), $lookup(Node, self) = user_i, RunInstr[self](instr_j, "d", inum), instr_j = instr_i, !($contains(Registers, inum) && $lookup(Registers, inum) > 0) => DecIntermediate[self](instr_i, true, inum, 0);
// d, register was not 0
Run(true), Done(false), State(user_i, instr_i), $lookup(Node, self) = user_i, DecIntermediate[self](instr_j, false, regnum, newval), instr_j = instr_i => Registers($insert(Registers, regnum, newval));
Run(true), Done(false), State(user_i, instr_i), $lookup(Node, self) = user_i, DecIntermediate[self](instr_j, false, regnum, newval), instr_j = instr_i, Registers(_), $lookup(Registers, regnum) = newval, !$contains(InstructionChars, instr_i + 2) => Done(true);
Run(true), Done(false), State(user_i, instr_i), $lookup(Node, self) = user_i, DecIntermediate[self](instr_j, false, regnum, newval), instr_j = instr_i, Registers(_), $lookup(Registers, regnum) = newval, $contains(InstructionChars, instr_i + 2), user_i + 1 = $count(Node) => State(0, instr_i + 2);
Run(true), Done(false), State(user_i, instr_i), $lookup(Node, self) = user_i, DecIntermediate[self](instr_j, false, regnum, newval), instr_j = instr_i, Registers(_), $lookup(Registers, regnum) = newval, $contains(InstructionChars, instr_i + 2), user_i + 1 != $count(Node) => State(user_i + 1, instr_i + 2);
// d, register was 0
Run(true), Done(false), State(user_i, instr_i), $lookup(Node, self) = user_i, DecIntermediate[self](instr_j, true, _, _), instr_j = instr_i, !$contains(InstructionChars, instr_i + 1) => Done(true);
Run(true), Done(false), State(user_i, instr_i), $lookup(Node, self) = user_i, DecIntermediate[self](instr_j, true, _, _), instr_j = instr_i, $contains(InstructionChars, instr_i + 1), user_i + 1 = $count(Node) => State(0, instr_i + 1);
Run(true), Done(false), State(user_i, instr_i), $lookup(Node, self) = user_i, DecIntermediate[self](instr_j, true, _, _), instr_j = instr_i, $contains(InstructionChars, instr_i + 1), user_i + 1 != $count(Node) => State(user_i + 1, instr_i + 1);
// t
Run(true), Done(false), State(user_i, instr_i), $lookup(Node, self) = user_i, RunInstr[self](instr_j, "t", inum), instr_j = instr_i, !$contains(InstructionChars, instr_i + inum) => Done(true);
Run(true), Done(false), State(user_i, instr_i), $lookup(Node, self) = user_i, RunInstr[self](instr_j, "t", inum), instr_j = instr_i, $contains(InstructionChars, instr_i + inum), user_i + 1 = $count(Node) => State(0, instr_i + inum);
Run(true), Done(false), State(user_i, instr_i), $lookup(Node, self) = user_i, RunInstr[self](instr_j, "t", inum), instr_j = instr_i, $contains(InstructionChars, instr_i + inum), user_i + 1 != $count(Node) => State(user_i + 1, instr_i + inum);
// Done!
Run(true), Done(true), State(user_i, instr_i), $lookup(Node, self) = user_i => @omlet.send(F, "text", "Result is: " + $toString(Registers));
Run(true), Done(true), State(user_i, instr_i), $lookup(Node, self) = user_i => Run(false);

}

====

MultiAction() {
var V1 : String;
var V2 : Number;
true => V1("foo"), V2(7), @$logger("bla");
}

====

RandomTest2() {
true => @$logger($toString($choice([1,2,3])));
}

====

TestOpOrder() {
true => @sabrina.say($toString(5-2+1));
}

====

TestNumber() {
var Num : Number;
var Mes : Measure(m);
!Num(_) => Num(-1.2e7);
!Num(_) => Num(1.2);
//!Mes(_) => Mes(1.5kg);
!Mes(_) => Mes(1.5km);
}

====

MultiparamRegex() {
@sabrina.listen(foo), $regex(foo, "([0-9]+) ([0-9]+)", "", v1, v2) =>
@$logger($toString(v1) + " " + $toString(v2));
}

====

TwitterHourlyCount() {
var TweetCount : Number;
!TweetCount(_) => TweetCount(0);
@$timer(1h) => TweetCount(0);
@twitter.source(_, _, _, _, _, yours), yours = false =>TweetCount( TweetCount + 1);
@$timer(1h) =>@$notify("Your Twitter feed has " + $toString(TweetCount) + " new tweets in the past hour");
}

====

CompareTest() {
var V1 : Number;
var V2 : Number;

@$timer(10s), (V1 - V2 < 3) => @$notify("foo");
}

====

TrueTest() {
true => @$logger("something");
}

====

RandomTest() {
true => @$logger($toString($random()));
}

====

KeywordTest() {
var Key1 : String;
var Key2 : String;

@$timer(30s), (Key1) = "foo" => Key1(Key2);
}

====

TwitterTrendingHashtag(NumberOfUsers : Number) {
var HashTagToUser : Map(String, Array(String));

!HashTagToUser(_) => HashTagToUser($emptyMap());

@$timer(1day) => HashTagToUser($emptyMap());

@twitter.source(_, hashtags, _, from, _, false),
HashTagToUser(dict), $contains(hashtags, tag), users := $lookup(dict, tag),
!$contains(users, from) =>
HashTagToUser($insert(dict, tag, $append(users, from)));

@$timer(1h), HashTagToUser(dict), $contains(dict, tag), $count($lookup(dict, tag)) >= NumberOfUsers =>
@$notify(tag + " is a trending hashtag today");

}

====

LinkedInApp[F] () {
var Company[F] : (String, String);
out Colleagues : Array((String, String));
var NewColleague : (String, String);
@linkedin.profile (name, co) =>Company[self](name, co);
Company[self](_,co), Company[m](name, co), m in F, m != self =>NewColleague(name, co);
NewColleague(name, co) => Colleagues($append(Colleagues, (name, co)));
NewColleague(name, co) => @$notify(name);
}

====

ParserTest() {
var Val : Number;
@sabrina.listen(text), $regex("^on\\s+hashtag\\s+([a-z0-9]+)", 42 = !!false) => Val(42);
}

====

SabrinaTestCapturingGroup() {
@sabrina.listen(text), $regex(text, "^on\\s+hashtag\\s+([a-z0-9]+)", "i", hashtag)
    => @sabrina.say("hashtag " + hashtag);
}

====

LinkedInApp[F]() {
    var Company[F] : (String, String);
    var NewColleague : (String, String);

    @linkedin.profile(name, _, ind) => Company[self](name, ind);
    Company[self](_, ind), Company[m](name, ind), m in F =>
        NewColleague(name, ind);
    NewColleague(name, co) => @$notify(name, co);
}

====

WeightCompetition[F](stopTime: String) {
    var InitialWeight[F] : (Measure(kg));
    var Weight : (Measure(kg));
    var Loss[F] : (Number);
    var Winner : (User);

    @(type="scale").source(_, w)
        => Weight(w);

    Weight(w), !InitialWeight[self](_)
        => InitialWeight[self](w);

    InitialWeight[self](w1), Weight(w2)
        => Loss[self]((w1 - w2)/w2);

    Loss[m](l), m in F
        => Winner($argMax(Loss));

    Winner(w)
        => @$notify(w);

    @$at(stopTime)
        => @$return(Winner);
}

====

TestComputeApp() {
    module random {
        event out(x : Number);
        function ask() {
            out(Math.floor(42 + Math.random() * 42));
        }
    }

    @$timer(30s) => @random.ask();
    @random.out(x) => @$logger('number: ' + $toString(x));
}

====

/* This should not run directly, but it gives an idea of the syntax */
/* They should all at least parse successfully. */

Test() {
    @test.source() => @$logger("Test App received an event on Test Channel");
}
