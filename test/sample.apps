// -* mode: js -*-

// ** typecheck: expect Error **
// ArrayPrincipals
now => @org.thingpedia.builtin.test(principal=["matrix-account:@testuser2:camembert.stanford.edu"^^tt:contact, "matrix-account:@testuser3:camembert.stanford.edu"^^tt:contact]).eat_data(data='AAAAAA');

====

// Array
edge @twitter.source() on new, in_array(from, ["alice"^^tt:hashtag, "bob"^^tt:hashtag])  => notify;

====

// TestExternalPredicate
{
edge @twitter.source() on new, @builtin.get_time() { time >= makeTime(9,0) && time <= makeTime(10, 0) } => notify;
edge @twitter.source() on new, text =~ "lol" && @builtin.get_time() { time >= makeTime(9,0) && time <= makeTime(10, 0) } => notify;
}

====

// ** typecheck: expect TypeError **
// these should not typecheck
// TestInvalidExternalPredicate1
edge @twitter.source() on new, @builtin.get_time() { time =~ "lol" } => notify;

====

// ** typecheck: expect TypeError **
// TestInvalidExternalPredicate2
edge @twitter.source() on new, @builtin.get_time() { text =~ "lol" } => notify;

====

// ** typecheck: expect Error **
// TestInvalidExternalPredicate3
edge @twitter.source() on new, @twitter.source() { text =~ "lol" } => notify;

====

executor = "bob"^^tt:contact_name : { // TestReturn
    edge @org.twitter.source() on new => return;
}

====

executor = self : { // ExplicitSelf
    now => @builtin.say(message="lol");
}

====

executor = "matrix-account:@gcampax:matrix.org"^^tt:contact : { // WithPrincipals
    now => @builtin.say(message="lol");
}

====

// CompareDate
{
    now => @builtin.get_time(), time > makeTime(10,0) => notify;
}

====

// StartsWith
{
    edge @twitter.source() on new, starts_with(text, "foo") => notify;
}

====

// EntityNames
{
    now => @twitter.post_picture(caption="lol", picture_url="http://foo.com/bar.jpg"^^tt:picture("A funny picture"));
}

====

// DownCast
{
    edge @xkcd(id="com.xkcd-6").get_comic() on new
    => @twitter.sink(status=picture_url);
}

====

// EventType
{
    edge @twitter.source() on new => @builtin.say(message=$event.type);
}

====

// FormatEvent
{
    edge @twitter.source() on new => @builtin.say(message=$event.title);
}

====

// ComplexFilter
{
    edge @twitter.source() on new, text =~ "foo" || (text =~"bar" && !(text =~ "lol")) => notify;
}

====

// WithClassDef
{
    class @dyn_0 extends @remote {
        action send(in req foo : String);
    }
    now => @dyn_0.send(foo="foo");
}

====

// ** typecheck: expect TypeError **
// WrongClassDef
{
    class @dyn_0 extends @remote {
        action send(in req foo : Number);
    }
    now => @dyn_0.send(foo="foo");
}

====

// without wrapping it should still work

edge @twitter.source() on new => notify;

====

// same for immediates
now => @security-camera.get_snapshot() => notify;

====

// PrimaryKind
edge @org.twitter.source() on new => notify;

====

// Principals
{
    edge @twitter(principal="omlet-account:foo"^^tt:contact).source() on new => notify;
    edge @twitter(principal="giovanni"^^tt:contact_name).source() on new => notify;
    // the following is identical to the previous one
    edge @twitter(principal="giovanni").source() on new => notify;
}

====

// Contains
{
    edge @twitter.source() on new, contains(hashtags, "lol") => notify;
}

====

// ParameterPassing
{
    edge @xkcd(id="com.xkcd-6").new_comic() on new
    => @twitter(id="twitter-foo").post_picture(caption=title, picture_url=picture_url);
}

====

// SecurityCamera
    now => @security-camera.get_snapshot() => notify;

====

// SearchYoutube
    now => @youtube.search_videos(query="lol"), video_url == "http://www.youtube.com"^^tt:url =>  notify;

====

// TimeTest
{
    attimer(time=makeTime(12, 30)) => notify;
}

====

// PhoneNumberTest
{
    now => @phone.send_sms(to="+15555555555", body="");
    now => @phone.send_sms(to="+15555555555"^^tt:phone_number, body="");
    edge @phone.receive_sms() on new, from=="+15555555555"^^phone_number => notify;
}

====

// ** typecheck: expect TypeError **
// InvalidPhoneNumberTest
    now => @phone.send_sms(to="+15555555555"^^tt:email_address, body="");

====

// LocationAsTriggerParam
    edge @weatherapi.weather(location=makeLocation(1, 3)) on new => notify;

====

// RelativeLocation
    edge @weatherapi.weather(location=$context.location.current_location) on new => notify;

====

// LocationWithDisplayAsTriggerParam
    edge @weatherapi.weather(location=makeLocation(1, 3, "Somewhere")) on new  => notify;

====

// SabrinaGeneratedMonitorTwitter
{
    edge @twitter(id="twitter-foo").source() on new, from == "HillaryClinton"^^tt:username => notify;
}

====

// CommandTest
  now => @builtin.say(message="test");

====

// LogQueryTest
    now => T => notify;

====

// LogQueryTestProjection
    now => [col1] of Q1 => notify;

====

// LogQueryTestSelection
    now => [col1] of (Q1, col2 >= 42) => notify;

/* select col1 as v_1 from Q1 where col2 >= 42 */

====

// LogQueryTestRemote
    now => [col1] of ("1234"^^tt:contact :: Q4, col2 >= 42) => notify;

====

// ** typecheck: expect TypeError **
// LogQueryTestRemoteInvalid1
// there is no such table Q0
now => [col1] of ("1234"^^tt:contact :: Q0, col2 >= 42) => notify;

====

// ** typecheck: expect TypeError **
// LogQueryTestRemoteInvalid2
// principal must be contact not group
now => [col1] of ("1234"^^tt:contact_group :: Q4, col2 >= 42) => notify;

====

// ** typecheck: expect TypeError **
// LogQueryTestRemoteInvalid2
// col1 is a string in Q4
now => [col1] of ("1234"^^tt:contact_group :: Q4, col1 >= 42) => notify;

====

// LogQueryTestJoin
{
  now => ([col1] of Q1 join Q2), col2 >= col1 => notify;
  now => [col2] of (([col1] of Q1 join Q2), col2 >= col1) => notify;
}

====

// LogQueryAggregationTest
now => aggregate max field of Q1 => notify;

====

// LogQueryAggregationMeasureTest
// col1 has type Measure(C)
{
now => aggregate max col1 of Q3 => @thermostat.set_target_temperature(value=max);
now => (aggregate max col1 of Q3) as tmp => @thermostat.set_target_temperature(value=tmp.max);
}

====

// ** typecheck: expect TypeError **
// LogQueryInvalidAggregationTest
now => aggregate max nonexisting_field of Q1 => notify;

====

// ** typecheck: expect TypeError **
// LogQueryInvalidAggregation2Test
now => aggregate max str1 of Q1 => notify;

====

// LogQueryCountTest
now => aggregate count of Q1 => notify;

====

// LogQueryCountParamPassingTest
now => aggregate count str1 of Q1 join @xkcd.get_comic(number=count) => notify;

====

// ** typecheck: expect TypeError **
// LogQueryCountInvalidParamPassingTest
now => aggregate count str1 of Q1 => @twitter.sink(status=count);

====

// LogQueryArgmTest
{
now => [field1, field2] of aggregate argmax col1 of Q0 => notify;
now => [field1, field2] of aggregate argmax 3 col1 of Q0 => notify;
}

====

// ** typecheck: expect TypeError **
// LogQueryInvalidArgmTest
now => [field1, field2] of aggregate argmax nonexisting_field of Q0 => notify;

====

// WithSave
{
let table steps    := @fitbit.get_steps();
let table my_table := aggregate max steps of Q1;
now => my_table => notify;
}

====

// LogTriggerTest
edge Q1 on new join Q2 => notify;

====

// LogTriggerAggregationTest
edge (aggregate max field of Q1) on new => notify;

====

// LogTriggerArgmTest
edge ([field1, field2] of aggregate argmax another_field of Q0) on new => notify;

====

// LogTestAll
let stream saved := [foo] of (edge Q0 on new join Q1);

====

// LogTestTableName
let stream lol := [foo] of (edge Q0 on new join Q1);

====

// RelativeTime
{
now => Q1, _timestamp > makeDate() + delta(-2year) => notify;
now => Q1, _timestamp > makeDate() + delta(-24mon) => notify;
now => Q1, _timestamp > makeDate() + delta(-1year + -12mon) => notify;
now => Q1, _timestamp > start_of(mon) && _timestamp < end_of(day) => notify;
}

====

// Lambdas
{
let table macro := \(number : Number) -> @xkcd.get_comic(number=number) ;
now => macro(number=1234) => notify;
}

====

// Edge Filter
{
edge @thermostat.get_temperature() on value > 70F => notify;
}
